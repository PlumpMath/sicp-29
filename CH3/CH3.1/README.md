##[Exercise3.01](Ex3.01.rkt)

##[Exercise3.02](Ex3.02.rkt)

##[Exercise3.03](Ex3.03.rkt)

##[Exercise3.04](Ex3.04.rkt)

##[Exercise3.05](Ex3.05.rkt)

##[Exercise3.06](Ex3.06.rkt)

##[Exercise3.07](Ex3.07.rkt)

##[Exercise3.08](Ex3.08.rkt)

##Exercise3.09

> In section 1.2.1 we used the substitution model to analyze two procedures for computing
   factorials, a recursive version
   
 ```racket

        (define (factorial n)
            (if (= n 1)
                1
                (* n (factorial (- n 1)))))

``` 

and an iterative version

```racket

    (define (factorial n)
        (fact-iter 1 1 n))
    (define (fact-iter product counter max-count)
        (if (> counter max-count)
            product
            (fact-iter (* counter product)
                            (+ counter 1)
                            max-count)))
```
Show the environment structures created by evaluating (factorial 6) using each version of the
factorial procedure.

`Solution: `

**Following is the procedure of creating recurison factorial.**

![image](https://github.com/Soyn/sicp/blob/master/screenshots/Ex3.09a.jpg)

**Following is the envirment structure created by evaluating (factorial 6)** 

![image](https://github.com/Soyn/sicp/blob/master/screenshots/Ex3.09b.jpg)

**Following is the envirment structure created by (factorial n)**

![image](https://github.com/Soyn/sicp/blob/master/screenshots/Ex3.09c.jpg)

**Following is the envirment structure created by evaluating ( factorial 6)**

![image](https://github.com/Soyn/sicp/blob/master/screenshots/Ex3.09d.jpg)

##Exercise3.10

> In the make-withdraw procedure, the local variable balance is created as a
   parameter of make-withdraw. We could also create the local state variable explicitly, using let, as
   follows:
   
   

```racket

    (define (make-withdraw initial-amount)
        (let ((balance initial-amount))
            (lambda (amount)
                (if (>= balance amount)
                    (begin (set! balance (- balance amount))
                    balance)
                    "Insufficient funds"))))
                
```

Recall from section 1.3.2 that let is simply syntactic sugar for a procedure call:

```racket

        (let ((<var> <exp>)) <body>)

```

is interpreted as an alternate syntax for

```racket

((lambda (<var>) <body>) <exp>)


```

Use the environment model to analyze this alternate version of make-withdraw, drawing figures like
the ones above to illustrate the interactions

```racket

    (define W1 (make-withdraw 100))
    (W1 50)
    (define W2 (make-withdraw 100))
    
```
>Show that the two versions of make-withdraw create objects with the same behavior. How do the
senvironment structures differ for the two versions?

`Solution: `

**Following is the envirment structure created by `make-withdraw`**

![image](https://github.com/Soyn/sicp/blob/master/screenshots/Ex3.10a.jpg)

**Following is the envirment structure created by '(define w1 ( make-withdraw 100)) , ( w1 50) and ( define ( w2 ( make-withdraw 100)))'**

![image](https://github.com/Soyn/sicp/blob/master/screenshots/Ex3.10b.jpg)


##Exercise3.11

>In section 3.2.3 we saw how the environment model described the behavior of procedures
    with local state. Now we have seen how internal definitions work. A typical message-passing procedure
    contains both of these aspects. Consider the bank account procedure of section 3.1.1:
    
```racket

(define (make-account balance)
    (define (withdraw amount)
        (if (>= balance amount)
            (begin (set! balance (- balance amount))
                        balance)
             "Insufficient funds"))
    (define (deposit amount)
        (set! balance (+ balance amount))
        balance)
    (define (dispatch m)
        (cond ((eq? m 'withdraw) withdraw)
                    ((eq? m 'deposit) deposit)
                    (else (error "Unknown request -- MAKE-ACCOUNT"
                                            m))))
       dispatch)
       
```

Show the environment structure generated by the sequence of interactions

```racket

(define acc (make-account 50))
((acc 'deposit) 40)
90
((acc 'withdraw) 60)
30

```

Where is the local state for acc kept? Suppose we define another account

```racket

(define acc2 (make-account 100))

```

How are the local states for the two accounts kept distinct? Which parts of the environment structure are
shared between acc and acc2?

**Following is the envirment structure created by `( define acc ( make-account 50))` and ((acc 'deposit) 40)**

`Note: ` the ((acc 'withdraw) 60) is similar with ((acc 'deposit) 40)


![image](https://github.com/Soyn/sicp/blob/master/screenshots/Ex3.11.jpg)


##Exercise3.12

>The following procedure for appending lists was introduced in section 2.2.1:

```racket

(define (append x y)
    (if (null? x)
        y
        (cons (car x) (append (cdr x) y))))
        
```

**Append** forms a new list by successively consing the elements of x onto y. The procedure append! is
similar to append, but it is a mutator rather than a constructor. It appends the lists by splicing them
together, modifying the final pair of x so that its cdr is now y. (It is an error to call append! with an
empty x.)

```racket

(define (append! x y)
    (set-cdr! (last-pair x) y)
    x)
```

Here last-pair is a procedure that returns the last pair in its argument:

```racket

(define (last-pair x)
    (if (null? (cdr x))
    x
    (last-pair (cdr x))))
    
```

Consider the interaction

```racket

(define x (list 'a 'b))
(define y (list 'c 'd))
(define z (append x y))
z
(a b c d)
(cdr x)
<response>
(define w (append! x y))
w
(a b c d)
(cdr x)
<response>

```

What are the missing <response>? Draw box-and-pointer diagrams to explain your answer.

`Solution: `
> the respnse is **(b)** and **(b c d)**, and following is the box-and-pointer diagram


![image](https://github.com/Soyn/sicp/blob/master/screenshots/Ex3.12a.jpg)

![image](https://github.com/Soyn/sicp/blob/master/screenshots/Ex3.12b.jpg)

##Exercise3.13

>Consider the following make-cycle procedure, which uses the last-pair procedure defined in exercise 3.12:

```racket

(define (make-cycle x)
    (set-cdr! (last-pair x) x)
    x)
    
```

Draw a box-and-pointer diagram that shows the structure **z** created by

```racket

(define z (make-cycle (list 'a 'b 'c)))
```
What happens if we try to compute (last-pair z)?

`Solution: `
>Following is the box-and-pointer diagram

![image](https://github.com/Soyn/sicp/blob/master/screenshots/Ex3.13.png)



** And if we compute the ```racket  (last-pair 'z') ``` we will drop into infinite loop. **
